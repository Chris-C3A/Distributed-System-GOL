// package main

// import (
// 	"fmt"
// 	"sync"

// 	"uk.ac.bris.cs/gameoflife/stubs"
// 	"uk.ac.bris.cs/gameoflife/util"
// )

// type WorkerOperations struct{}

// // global variables
// var world [][]uint8
// var turn = 0
// var mutex sync.Mutex
// var terminate = false

// // var haloTopChan = make(chan []byte)
// // var haloBottomChan = make(chan []byte)

// // var haloTopToSend = make(chan []byte)
// // var haloBottomToSend = make(chan []byte)

// var haloTopChan chan []byte
// var haloBottomChan chan []byte

// var haloTopToSend chan []byte
// var haloBottomToSend chan []byte

// var done = false

// // will have extra top row and bottom row to use
// // startY and endY will not be needed anymore since only the actual part of the world that needs to be processed is being sent


// // RPC method to assign the world before evolving GoL
// // run worker
// // probably have a chan for the halos when received and sent back
// func (s *WorkerOperations) InitWorker(req stubs.Request, res *stubs.Response) (err error) {
// 	// initalize channels
// 	mutex.Lock()
// 	// add variable to check if already initialized
// 	haloTopChan = make(chan []byte)
// 	haloBottomChan = make(chan []byte)

// 	haloTopToSend = make(chan []byte)
// 	haloBottomToSend = make(chan []byte)
// 	mutex.Unlock()

// 	fmt.Println("Worker initalized by broker")
// 	// reset globally values when evolveGoL is called
// 	turn = 0

// 	// receive halos and send on channel
// 	haloTopChan <- req.HaloTop
// 	haloBottomChan <- req.HaloBottom

// 	// mutex.Lock()
// 	// subworld to compute
// 	world = req.World
// 	// run worker as a go routine
// 	go worker(req.Turns)
// 	// mutex.Unlock()

// 	fmt.Println("running worker")

// 	// wait to receive first halos
// 	res.HaloTop = <- haloTopToSend
// 	res.HaloBottom = <- haloBottomToSend

// 	fmt.Println("init successful")

// 	return 
// }

// // rpc call to send and receive halos
// func (s *WorkerOperations) HaloExchange(req stubs.Request, res *stubs.Response) (err error) {
// 	// receive halos and send on channel
// 	fmt.Println("turn", turn)
// 	fmt.Println("halo exchnage called")
// 	mutex.Lock()
// 	haloTopChan <- req.HaloTop
// 	haloBottomChan <- req.HaloBottom
// 	mutex.Unlock()
// 	fmt.Println("sent to channels")
// 	// this will continue its turn

// 	// return world when all iterations have finished
// 	if done {
// 		res.World = world
// 		return
// 	}

// 	fmt.Println("sending halos to broker")
// 	// get halos after the iteration to send back to broker
// 	mutex.Lock()
// 	res.HaloTop = <- haloTopToSend
// 	res.HaloBottom = <- haloBottomToSend
// 	mutex.Unlock()

// 	return
// }

// // RPC methods
// // func (s *WorkerOperations) EvolveGoL(req stubs.Request, res *stubs.Response) (err error) {

// // 	// exclude halos
// // 	// mutex.Lock()
// // 	// exclude halos (no need)
// // 	// world = world[1:len(world)-1]
// // 	// mutex.Unlock()
// // 	res.World = world

// // 	// return halos separately
// // 	// res.HaloTop = world[0]
// // 	// res.HaloBottom = world[len(world)-1]

// // 	// no need for this
// // 	// res.AliveCells = util.CalculateAliveCells(world)

// // 	return
// // }


// // not used anymore
// func (s *WorkerOperations) RequestAliveCellsCount(req stubs.Request, res *stubs.Response) (err error) {
// 	mutex.Lock()
// 	res.AliveCellsCount = len(util.CalculateAliveCells(world))
// 	res.CompletedTurns = turn
// 	mutex.Unlock()

// 	return
// }

// // to use later on
// func (s *WorkerOperations) RequestCurrentGameState(req stubs.Request, res *stubs.Response) (err error) {
// 	mutex.Lock()
// 	res.World = world
// 	res.CompletedTurns = turn
// 	mutex.Unlock()

// 	return
// }

// func (s *WorkerOperations) Shutdown(req stubs.Request, res *stubs.Response) (err error) {
// 	terminate = true

// 	server.Stop()

// 	return
// }


// // worker function
// func worker(turns int) {
// 	for turn < turns && !terminate {
// 		mutex.Lock()
		
// 		// receive halos to include in next iteration calculation
// 		haloTop := <-haloTopChan
// 		haloBottom := <-haloBottomChan

// 		world = util.CalculateNextState(world, haloTop, haloBottom)

// 		// TODO continue from here
// 		// get halos from world

// 		// after each turn update the halos and send to the broker
// 		// wait for halos

// 		// send halos to send to other workers
// 		haloTopToSend <- world[0]
// 		haloBottomToSend <- world[len(world)-1]

// 		turn++
// 		mutex.Unlock()
// 	}

// 	// send done channel?
// 	done = true
// }
